package {{PACKAGE}};

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.NullAndEmptySource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.Method;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for {@link {{CLASS_NAME}}}.
 *
 * Generated by JUnit Test Case Generator skill.
 */
@ExtendWith(MockitoExtension.class)
class {{CLASS_NAME}}Test {

    // ==================== MOCKS ====================
    {{#DEPENDENCIES}}
    @Mock
    private {{DEPENDENCY_TYPE}} {{DEPENDENCY_NAME}};
    {{/DEPENDENCIES}}

    // ==================== SYSTEM UNDER TEST ====================
    @InjectMocks
    private {{CLASS_NAME}} underTest;

    // ==================== SETUP ====================
    @BeforeEach
    void setUp() {
        // Additional setup if needed
    }

    // ==================== PUBLIC METHOD TESTS ====================
    {{#PUBLIC_METHODS}}

    @Nested
    @DisplayName("{{METHOD_NAME}} tests")
    class {{METHOD_NAME_CAPITALIZED}}Tests {

        @Test
        @DisplayName("should return expected result when valid input")
        void {{METHOD_NAME}}_ShouldReturnExpected_WhenValidInput() {
            // Arrange
            {{#HAS_DEPENDENCIES}}
            when({{MOCK_SETUP}}).thenReturn({{MOCK_RETURN}});
            {{/HAS_DEPENDENCIES}}

            // Act
            {{RETURN_TYPE}} result = underTest.{{METHOD_NAME}}({{PARAMS}});

            // Assert
            assertNotNull(result);
            {{#HAS_DEPENDENCIES}}
            verify({{VERIFY_MOCK}});
            {{/HAS_DEPENDENCIES}}
        }

        {{#HAS_NULLABLE_PARAMS}}
        @Test
        @DisplayName("should handle null input appropriately")
        void {{METHOD_NAME}}_ShouldHandleNull_WhenNullInput() {
            // Arrange & Act & Assert
            assertThrows(NullPointerException.class,
                () -> underTest.{{METHOD_NAME}}(null));
        }
        {{/HAS_NULLABLE_PARAMS}}

        {{#THROWS_EXCEPTION}}
        @Test
        @DisplayName("should throw {{EXCEPTION_TYPE}} when {{EXCEPTION_CONDITION}}")
        void {{METHOD_NAME}}_ShouldThrow_When{{EXCEPTION_CONDITION_CAMEL}}() {
            // Arrange
            {{EXCEPTION_SETUP}}

            // Act & Assert
            assertThrows({{EXCEPTION_TYPE}}.class,
                () -> underTest.{{METHOD_NAME}}({{EXCEPTION_PARAMS}}));
        }
        {{/THROWS_EXCEPTION}}
    }
    {{/PUBLIC_METHODS}}

    // ==================== PRIVATE METHOD TESTS (via Reflection) ====================
    {{#PRIVATE_METHODS}}

    @Nested
    @DisplayName("{{METHOD_NAME}} (private) tests")
    class {{METHOD_NAME_CAPITALIZED}}PrivateTests {

        @Test
        @DisplayName("should return expected result when valid input")
        void {{METHOD_NAME}}_ShouldReturnExpected_WhenValidInput() throws Exception {
            // Arrange
            Method method = {{CLASS_NAME}}.class.getDeclaredMethod(
                "{{METHOD_NAME}}"{{#HAS_PARAMS}},
                {{PARAM_TYPES}}{{/HAS_PARAMS}}
            );
            method.setAccessible(true);

            // Act
            Object result = method.invoke(underTest{{#HAS_PARAMS}}, {{PARAM_VALUES}}{{/HAS_PARAMS}});

            // Assert
            assertNotNull(result);
            {{#HAS_EXPECTED}}
            assertEquals({{EXPECTED_VALUE}}, result);
            {{/HAS_EXPECTED}}
        }
    }
    {{/PRIVATE_METHODS}}

    // ==================== STATIC METHOD TESTS (via MockedStatic) ====================
    {{#STATIC_METHODS}}

    @Nested
    @DisplayName("{{METHOD_NAME}} (static) tests")
    class {{METHOD_NAME_CAPITALIZED}}StaticTests {

        @Test
        @DisplayName("should return expected result")
        void {{METHOD_NAME}}_ShouldReturnExpected() {
            try (MockedStatic<{{CLASS_NAME}}> mocked = mockStatic({{CLASS_NAME}}.class)) {
                // Arrange
                mocked.when(() -> {{CLASS_NAME}}.{{METHOD_NAME}}({{MOCK_PARAMS}}))
                      .thenReturn({{MOCK_RETURN}});

                // Act
                {{RETURN_TYPE}} result = {{CLASS_NAME}}.{{METHOD_NAME}}({{PARAMS}});

                // Assert
                assertEquals({{EXPECTED}}, result);
                mocked.verify(() -> {{CLASS_NAME}}.{{METHOD_NAME}}({{VERIFY_PARAMS}}));
            }
        }
    }
    {{/STATIC_METHODS}}

    // ==================== HELPER METHODS ====================

    /**
     * Creates a valid test instance with default values.
     */
    private {{CLASS_NAME}} createValidInstance() {
        // TODO: Implement based on class requirements
        return new {{CLASS_NAME}}();
    }
}
